"""
WebRTC Peer Connection Manager - FIXED VERSION
Handles aiortc peer connections with proper ICE candidate handling
"""
import asyncio
import logging
from typing import Dict, Optional, Callable, Awaitable
from datetime import datetime
import json

from aiortc import (
    RTCPeerConnection, 
    RTCSessionDescription, 
    RTCConfiguration, 
    RTCIceServer,
    RTCIceCandidate  # âœ… ADDED: Required for adding candidates
)
from aiortc.contrib.media import MediaBlackhole, MediaRecorder

from ..config import config

logger = logging.getLogger(__name__)


class PeerConnectionManager:
    """
    Manages WebRTC peer connections using aiortc
    One peer connection per WebSocket session
    """
    
    def __init__(self):
        self.peers: Dict[str, RTCPeerConnection] = {}
        self.audio_tracks: Dict[str, object] = {}
        self.on_track_callback: Optional[Callable] = None
        
        # ICE server configuration - SIMPLIFIED per aiortc best practices
        self.ice_servers = self._create_ice_servers()
        self.rtc_configuration = RTCConfiguration(iceServers=self.ice_servers)
        
        logger.info(f"PeerConnectionManager initialized with {len(self.ice_servers)} ICE servers")
    
    def _create_ice_servers(self) -> list:
        """
        Create RTCIceServer list - SIMPLIFIED per aiortc recommendations
        Using 1-2 reliable STUN servers is better than many
        """
        ice_servers = []
        
        # âœ… PRIMARY: Use Google's primary STUN (most reliable)
        ice_servers.append(RTCIceServer(urls="stun:stun.l.google.com:19302"))
        logger.info("Added primary STUN: stun.l.google.com:19302")
        
        # âœ… BACKUP: Add one backup STUN
        ice_servers.append(RTCIceServer(urls="stun:stun.cloudflare.com:3478"))
        logger.info("Added backup STUN: stun.cloudflare.com:3478")
        
        # Add TURN servers if configured
        if config.webrtc.turn_servers:
            for turn_url in config.webrtc.turn_servers:
                turn_server = RTCIceServer(urls=turn_url)
                if config.webrtc.turn_username and config.webrtc.turn_password:
                    turn_server.username = config.webrtc.turn_username
                    turn_server.credential = config.webrtc.turn_password
                ice_servers.append(turn_server)
                logger.info(f"Added TURN server: {turn_url}")
        
        return ice_servers
    
    def set_track_handler(self, callback: Callable[[str, object], Awaitable[None]]):
        """Set callback for handling incoming media tracks"""
        self.on_track_callback = callback
        logger.info("Track handler registered")
    
    async def create_peer_connection(self, session_id: str) -> RTCPeerConnection:
        """Create a new RTCPeerConnection for a session"""
        logger.info(f"[{session_id[:8]}] Creating peer connection...")
        
        # Create peer connection with ICE servers
        pc = RTCPeerConnection(configuration=self.rtc_configuration)
        
        # Store the peer connection
        self.peers[session_id] = pc
        
        # Set up event handlers
        @pc.on("iceconnectionstatechange")
        async def on_ice_connection_state_change():
            logger.info(f"[{session_id[:8]}] ICE connection state: {pc.iceConnectionState}")
            
            if pc.iceConnectionState == "connected":
                logger.info(f"[{session_id[:8]}] âœ… ICE connection established!")
            elif pc.iceConnectionState == "failed":
                logger.error(f"[{session_id[:8]}] âŒ ICE connection failed")
                await self.close_peer_connection(session_id)
        
        @pc.on("connectionstatechange")
        async def on_connection_state_change():
            logger.info(f"[{session_id[:8]}] Connection state: {pc.connectionState}")
            
            if pc.connectionState == "connected":
                logger.info(f"[{session_id[:8]}] âœ… WebRTC connected!")
            elif pc.connectionState == "failed":
                logger.error(f"[{session_id[:8]}] Connection failed")
                await self.close_peer_connection(session_id)

        # Find your existing @pc.on("icecandidate") handler and replace it with:
        @pc.on("icecandidate")
        async def on_ice_candidate(candidate):
            """
            Handle ICE candidates generated by aiortc
            MUST forward these to the frontend!
            """
            if candidate:
                logger.info(f"[{session_id[:8]}] ðŸ§Š Backend ICE candidate generated")
                logger.debug(f"[{session_id[:8]}]   Type: {candidate.type}")
                logger.debug(f"[{session_id[:8]}]   Protocol: {candidate.protocol}")
                logger.debug(f"[{session_id[:8]}]   Address: {candidate.ip}:{candidate.port}")
                
                if candidate.type == "srflx":
                    logger.info(f"[{session_id[:8]}] âœ… Server reflexive candidate (public IP discovered)")
                
                # âœ… CRITICAL FIX: Send to frontend via WebSocket
                try:
                    # Import here to avoid circular imports
                    from ..app import manager
                    
                    candidate_dict = {
                        "candidate": f"candidate:{candidate.foundation} {candidate.component} {candidate.protocol} {candidate.priority} {candidate.ip} {candidate.port} typ {candidate.type}",
                        "sdpMLineIndex": 0,
                        "sdpMid": "0"
                    }
                    
                    ice_message = {
                        "type": "ice_candidate", 
                        "candidate": candidate_dict
                    }
                    
                    await manager.send_message(session_id, ice_message)
                    logger.info(f"[{session_id[:8]}] âœ… Backend ICE candidate sent to frontend")
                    
                except Exception as e:
                    logger.error(f"[{session_id[:8]}] Error sending ICE candidate: {e}")
            else:
                logger.info(f"[{session_id[:8]}] ðŸ Backend ICE gathering completed")

        @pc.on("icegatheringstatechange")
        async def on_ice_gathering_state_change():
            logger.info(f"[{session_id[:8]}] ICE gathering state: {pc.iceGatheringState}")
        
        @pc.on("track")
        async def on_track(track):
            logger.info(f"[{session_id[:8]}] ðŸŽ¤ Received {track.kind} track")
            
            if track.kind == "audio":
                self.audio_tracks[session_id] = track
                
                if self.on_track_callback:
                    await self.on_track_callback(session_id, track)
                else:
                    logger.warning(f"[{session_id[:8]}] No track handler registered!")
                
                @track.on("ended")
                async def on_ended():
                    logger.info(f"[{session_id[:8]}] Audio track ended")
                    if session_id in self.audio_tracks:
                        del self.audio_tracks[session_id]
        
        logger.info(f"[{session_id[:8]}] âœ… Peer connection created")
        return pc
    
    async def handle_offer(self, session_id: str, sdp: str) -> str:
        """Handle WebRTC offer from client and create answer"""
        try:
            logger.info(f"[{session_id[:8]}] Processing WebRTC offer...")
            
            # Create or get peer connection
            if session_id not in self.peers:
                pc = await self.create_peer_connection(session_id)
            else:
                pc = self.peers[session_id]
                logger.warning(f"[{session_id[:8]}] Reusing existing peer connection")
            
            # Parse the offer
            offer = RTCSessionDescription(sdp=sdp, type="offer")
            
            # Set remote description (the offer)
            await pc.setRemoteDescription(offer)
            logger.info(f"[{session_id[:8]}] âœ… Remote description set")
            
            # Create answer
            answer = await pc.createAnswer()
            
            # Set local description (our answer)
            await pc.setLocalDescription(answer)
            logger.info(f"[{session_id[:8]}] âœ… Local description set")
            
            # Return the SDP answer
            answer_sdp = pc.localDescription.sdp
            logger.info(f"[{session_id[:8]}] âœ… Answer created, ICE gathering will start")
            
            return answer_sdp
            
        except Exception as e:
            logger.error(f"[{session_id[:8]}] âŒ Error handling offer: {e}", exc_info=True)
            raise
    
    async def add_ice_candidate(self, session_id: str, candidate: dict):
        """
        âœ… CRITICAL FIX: Actually add ICE candidate from client
        This was missing before!
        """
        try:
            if session_id not in self.peers:
                logger.warning(f"[{session_id[:8]}] No peer connection for ICE candidate")
                return
            
            pc = self.peers[session_id]
            
            # Handle end-of-candidates signal
            if not candidate or not candidate.get("candidate"):
                logger.info(f"[{session_id[:8]}] ðŸ End of frontend ICE candidates")
                return
            
            # âœ… CRITICAL: Create and add the ICE candidate
            ice_candidate = RTCIceCandidate(
                candidate=candidate.get("candidate"),
                sdpMLineIndex=candidate.get("sdpMLineIndex"),
                sdpMid=candidate.get("sdpMid")
            )
            
            # Add to peer connection
            await pc.addIceCandidate(ice_candidate)
            
            logger.info(f"[{session_id[:8]}] âœ… Frontend ICE candidate added")
            logger.debug(f"[{session_id[:8]}]   Candidate: {candidate.get('candidate')[:50]}...")
            
        except Exception as e:
            logger.error(f"[{session_id[:8]}] âŒ Error adding ICE candidate: {e}", exc_info=True)
    
    async def close_peer_connection(self, session_id: str):
        """Close and cleanup peer connection"""
        try:
            if session_id in self.peers:
                pc = self.peers[session_id]
                
                logger.info(f"[{session_id[:8]}] Closing peer connection...")
                
                # Close the connection
                await pc.close()
                
                # Remove from tracking
                del self.peers[session_id]
                
                logger.info(f"[{session_id[:8]}] âœ… Peer connection closed")
            
            # Clean up audio track
            if session_id in self.audio_tracks:
                del self.audio_tracks[session_id]
                logger.info(f"[{session_id[:8]}] âœ… Audio track cleaned up")
                
        except Exception as e:
            logger.error(f"[{session_id[:8]}] Error closing peer connection: {e}")
    
    def get_peer_connection(self, session_id: str) -> Optional[RTCPeerConnection]:
        """Get peer connection for a session"""
        return self.peers.get(session_id)
    
    def get_audio_track(self, session_id: str) -> Optional[object]:
        """Get audio track for a session"""
        return self.audio_tracks.get(session_id)
    
    def get_connection_count(self) -> int:
        """Get number of active connections"""
        return len(self.peers)
    
    def get_connection_stats(self) -> dict:
        """Get statistics about connections"""
        stats = {
            "total_connections": len(self.peers),
            "active_audio_tracks": len(self.audio_tracks),
            "connections": {}
        }
        
        for session_id, pc in self.peers.items():
            stats["connections"][session_id[:8]] = {
                "connection_state": pc.connectionState,
                "ice_connection_state": pc.iceConnectionState,
                "ice_gathering_state": pc.iceGatheringState,
                "has_audio_track": session_id in self.audio_tracks
            }
        
        return stats
    
    async def cleanup_all(self):
        """Close all peer connections"""
        logger.info("Closing all peer connections...")
        
        session_ids = list(self.peers.keys())
        for session_id in session_ids:
            await self.close_peer_connection(session_id)
        
        logger.info(f"âœ… All {len(session_ids)} peer connections closed")


# Global peer connection manager instance
peer_connection_manager = PeerConnectionManager()