#!/bin/bash

# OpenCTI Installation Script for June Platform
# This script deploys OpenCTI as part of the June Platform

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
NAMESPACE="default"
RELEASE_NAME="june-platform"
CHART_PATH="helm/june-platform"
VALUES_FILE="values-production.yaml"

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    # Check if kubectl is available
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl is not installed or not in PATH"
    fi
    
    # Check if helm is available
    if ! command -v helm &> /dev/null; then
        log_error "helm is not installed or not in PATH"
    fi
    
    # Check if cluster is accessible
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Cannot connect to Kubernetes cluster"
    fi
    
    # Check if config.env exists
    if [ ! -f "config.env" ]; then
        log_error "config.env file not found. Please copy config.env.example to config.env and configure it."
    fi
    
    log_success "Prerequisites check passed"
}

# Load configuration
load_config() {
    log_info "Loading configuration from config.env..."
    source config.env
    
    # Validate required variables
    if [ -z "$DOMAIN" ]; then
        log_error "DOMAIN is not set in config.env"
    fi
    
    if [ -z "$LETSENCRYPT_EMAIL" ]; then
        log_error "LETSENCRYPT_EMAIL is not set in config.env"
    fi
    
    log_success "Configuration loaded successfully"
}

# Generate OpenCTI secrets
generate_secrets() {
    log_info "Generating OpenCTI secrets..."
    
    # Generate UUID for admin token if not provided
    if [ -z "$OPENCTI_ADMIN_TOKEN" ]; then
        OPENCTI_ADMIN_TOKEN=$(uuidgen 2>/dev/null || python3 -c "import uuid; print(str(uuid.uuid4()))" 2>/dev/null || openssl rand -hex 16)
        log_info "Generated OpenCTI admin token: $OPENCTI_ADMIN_TOKEN"
    fi
    
    # Set default passwords if not provided
    OPENCTI_ADMIN_PASSWORD=${OPENCTI_ADMIN_PASSWORD:-"OpenCTI2024!"}
    OPENCTI_RABBITMQ_PASSWORD=${OPENCTI_RABBITMQ_PASSWORD:-"RabbitMQ2024!"}
    OPENCTI_MINIO_SECRET=${OPENCTI_MINIO_SECRET:-"MinIO2024!"}
    
    log_success "OpenCTI secrets generated"
}

# Check existing deployment
check_existing_deployment() {
    log_info "Checking for existing deployments..."
    
    # Check if Helm release already exists
    if helm list -n "$NAMESPACE" | grep -q "$RELEASE_NAME"; then
        log_info "Found existing Helm release: $RELEASE_NAME"
        DEPLOYMENT_MODE="upgrade"
    else
        log_info "No existing Helm release found"
        DEPLOYMENT_MODE="install"
        
        # Check for existing resources that might conflict
        EXISTING_RESOURCES=$(kubectl get all -n "$NAMESPACE" --no-headers 2>/dev/null | wc -l || echo "0")
        if [ "$EXISTING_RESOURCES" -gt "0" ]; then
            log_warning "Found $EXISTING_RESOURCES existing resources in namespace $NAMESPACE"
            log_warning "These resources might not be managed by Helm"
            
            # Ask user what to do
            echo "Options:"
            echo "1. Continue anyway (may cause conflicts)"
            echo "2. Use a different namespace"
            echo "3. Exit and manually clean up"
            read -p "Choose option (1-3): " choice
            
            case $choice in
                1)
                    log_warning "Continuing with existing resources..."
                    ;;
                2)
                    read -p "Enter new namespace: " NAMESPACE
                    log_info "Using namespace: $NAMESPACE"
                    ;;
                3)
                    log_info "Exiting. Please clean up existing resources first."
                    exit 0
                    ;;
                *)
                    log_error "Invalid choice"
                    ;;
            esac
        fi
    fi
}

# Create values file for production
create_values_file() {
    log_info "Creating production values file..."
    
    cat > "$VALUES_FILE" << EOF
# Production values for June Platform with OpenCTI
# Generated by install-opencti.sh

global:
  domain: $DOMAIN
  environment: production

domains:
  primary: $DOMAIN
  api: api.$DOMAIN
  idp: idp.$DOMAIN
  stt: stt.$DOMAIN
  tts: tts.$DOMAIN
  turn: turn.$DOMAIN
  opencti: opencti.$DOMAIN

certificate:
  enabled: true
  issuer: letsencrypt-prod
  email: $LETSENCRYPT_EMAIL
  secretName: ${DOMAIN//./-}-wildcard-tls
  useBackup: false

postgresql:
  enabled: true
  database: keycloak
  username: keycloak
  password: "${POSTGRESQL_PASSWORD:-Pokemon123!}"
  storageClass: local-storage
  storage: 10Gi
  hostPath: /opt/june-postgresql-data

keycloak:
  enabled: true
  adminUsername: admin
  adminPassword: "${KEYCLOAK_ADMIN_PASSWORD:-Pokemon123!}"
  realm: june-realm

livekit:
  enabled: false
  namespace: media

orchestrator:
  enabled: true
  replicas: 1
  image:
    repository: docker.io/ozzuworld/june-orchestrator
    tag: latest
    pullPolicy: Always
  resources:
    requests:
      memory: 512Mi
      cpu: 200m
    limits:
      memory: 1Gi
      cpu: 500m

stt:
  enabled: ${ENABLE_STT:-true}
  replicas: 1
  image:
    repository: docker.io/ozzuworld/june-stt
    tag: latest
    pullPolicy: Always
  gpu:
    enabled: ${GPU_ENABLED:-false}
    count: 1
  resources:
    requests:
      memory: 6Gi
      cpu: "1"
    limits:
      memory: 6Gi
      cpu: "2"

tts:
  enabled: ${ENABLE_TTS:-true}
  replicas: 1
  image:
    repository: docker.io/ozzuworld/june-tts
    tag: latest
    pullPolicy: Always
  gpu:
    enabled: ${GPU_ENABLED:-false}
    count: 1
  resources:
    requests:
      memory: 4Gi
      cpu: "1"
    limits:
      memory: 6Gi
      cpu: "2"

stunner:
  enabled: false
  username: "${TURN_USERNAME:-june-user}"
  password: "${STUNNER_PASSWORD:-Pokemon123!}"

# OpenCTI Configuration
opencti:
  enabled: true
  replicas: 1
  domain: opencti.$DOMAIN
  
  image:
    repository: opencti/platform
    tag: "6.3.7"
    pullPolicy: IfNotPresent
    
  admin:
    email: "$LETSENCRYPT_EMAIL"
    password: "$OPENCTI_ADMIN_PASSWORD"
    token: "$OPENCTI_ADMIN_TOKEN"
    
  storage:
    storageClass: local-storage
    
  resources:
    requests:
      memory: "2Gi"
      cpu: "500m"
    limits:
      memory: "4Gi"
      cpu: "1000m"
      
  redis:
    storage: "5Gi"
    
  elasticsearch:
    storage: "50Gi"
    
  rabbitmq:
    username: "opencti"
    password: "$OPENCTI_RABBITMQ_PASSWORD"
    storage: "10Gi"
    
  minio:
    accessKey: "opencti"
    secretKey: "$OPENCTI_MINIO_SECRET"
    storage: "100Gi"

secrets:
  geminiApiKey: "$GEMINI_API_KEY"
  cloudflareToken: "$CLOUDFLARE_TOKEN"
EOF
    
    log_success "Production values file created: $VALUES_FILE"
}

# Deploy OpenCTI
deploy_opencti() {
    log_info "Deploying OpenCTI with June Platform..."
    
    # Create namespace if it doesn't exist (without Helm labels that cause conflicts)
    if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
        kubectl create namespace "$NAMESPACE"
        log_info "Created namespace: $NAMESPACE"
    fi
    
    # Deploy using Helm
    if [ "$DEPLOYMENT_MODE" = "upgrade" ]; then
        log_info "Upgrading existing June Platform deployment..."
        helm upgrade "$RELEASE_NAME" "$CHART_PATH" \
            --namespace "$NAMESPACE" \
            --values "$VALUES_FILE" \
            --timeout 15m0s \
            --wait
    else
        log_info "Installing June Platform with OpenCTI..."
        helm install "$RELEASE_NAME" "$CHART_PATH" \
            --namespace "$NAMESPACE" \
            --values "$VALUES_FILE" \
            --timeout 15m0s \
            --wait
    fi
    
    log_success "OpenCTI deployment completed"
}

# Show deployment status
show_status() {
    log_info "OpenCTI Deployment Status:"
    echo
    
    # Show service status
    kubectl get pods -l app.kubernetes.io/name=june-platform -n "$NAMESPACE" --show-labels
    echo
    
    # Show services
    kubectl get svc -l app.kubernetes.io/name=june-platform -n "$NAMESPACE"
    echo
    
    # Show ingress
    kubectl get ingress -n "$NAMESPACE"
    echo
    
    log_success "OpenCTI is accessible at: https://opencti.$DOMAIN"
    log_info "Default credentials:"
    echo "  Email: $LETSENCRYPT_EMAIL"
    echo "  Password: $OPENCTI_ADMIN_PASSWORD"
    echo "  Admin Token: $OPENCTI_ADMIN_TOKEN"
    echo
    log_warning "Please change the default passwords in production!"
}

# Cleanup function
cleanup() {
    if [ "${KEEP_VALUES_FILE:-false}" != "true" ]; then
        log_info "Cleaning up temporary files..."
        rm -f "$VALUES_FILE"
    fi
}

# Main execution
main() {
    log_info "Starting OpenCTI installation for June Platform..."
    
    # Set up cleanup trap
    trap cleanup EXIT
    
    # Execute installation steps
    check_prerequisites
    load_config
    generate_secrets
    check_existing_deployment
    create_values_file
    deploy_opencti
    show_status
    
    log_success "OpenCTI installation completed successfully!"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        --release-name)
            RELEASE_NAME="$2"
            shift 2
            ;;
        --keep-values)
            KEEP_VALUES_FILE="true"
            shift
            ;;
        --help)
            echo "Usage: $0 [OPTIONS]"
            echo "Options:"
            echo "  --namespace NAMESPACE    Kubernetes namespace (default: default)"
            echo "  --release-name NAME      Helm release name (default: june-platform)"
            echo "  --keep-values           Keep generated values file after deployment"
            echo "  --help                  Show this help message"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            ;;
    esac
done

# Run main function
main