name: ğŸš€ Complete June Services CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
        default: 'latest'
        type: string
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options: [production, staging, development]
      services:
        description: 'Services to deploy (comma-separated, empty for all)'
        required: false
        default: ''
        type: string
      force_restart:
        description: 'Force restart deployments'
        required: false
        default: false
        type: boolean
      build_images:
        description: 'Build and push Docker images'
        required: false
        default: true
        type: boolean

env:
  REGISTRY: docker.io/${{ secrets.DOCKERHUB_USERNAME }}
  KUBE_NAMESPACE: june-services
  IMAGE_TAG: ${{ github.event.inputs.image_tag || github.sha }}

permissions:
  contents: read
  packages: write

jobs:
  # Build and Push Docker Images
  build-and-push:
    name: ğŸ”¨ Build & Push Images
    runs-on: self-hosted
    if: github.event.inputs.build_images != 'false'

    strategy:
      fail-fast: false
      matrix:
        service:
          - june-stt
          - june-tts
          - june-orchestrator
          - june-idp
          - june-web
          - june-dark

    steps:
      - name: ğŸ“¦ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ” Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: ğŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ“ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ env.IMAGE_TAG }}

      - name: ğŸ—ï¸ Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  # Deploy to Kubernetes
  deploy:
    name: ğŸš€ Deploy to K8s
    runs-on: self-hosted
    needs: build-and-push
    if: always() && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')

    steps:
      - name: ğŸ“¦ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ” Verify k8s manifest files
        run: |
          set -e
          echo "ğŸ” Verifying k8s manifest files..."
          ls -la k8s || true
          # Required files
          test -f k8s/namespace.yaml       && echo "âœ… k8s/namespace.yaml"       || (echo "âŒ missing k8s/namespace.yaml"; exit 1)
          test -f k8s/configmap.yaml       && echo "âœ… k8s/configmap.yaml"       || (echo "âŒ missing k8s/configmap.yaml"; exit 1)
          # Secrets are optional here if you render them elsewhere; we apply if present
          test -f k8s/secrets.yaml         && echo "â„¹ï¸ k8s/secrets.yaml present" || echo "â„¹ï¸ k8s/secrets.yaml not found (ok)"

      - name: ğŸ” Verify Kubernetes connection
        run: |
          echo "ğŸ” Testing Kubernetes connection..."
          kubectl cluster-info
          kubectl get nodes -o wide
          echo "ğŸ“Š Current namespace status:"
          kubectl get all -n $KUBE_NAMESPACE || echo "Namespace doesn't exist yet"

      - name: ğŸ” Ensure Docker Registry Secret (for image pulls)
        run: |
          # Create/update the image pull secret in the target namespace
          kubectl create secret docker-registry dockerhub-secret \
            --docker-server=docker.io \
            --docker-username='${{ secrets.DOCKERHUB_USERNAME }}' \
            --docker-password='${{ secrets.DOCKERHUB_TOKEN }}' \
            --docker-email='${{ secrets.DOCKERHUB_EMAIL }}' \
            --namespace="$KUBE_NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Attach it to the default ServiceAccount so ALL pods can pull private images
          kubectl -n "$KUBE_NAMESPACE" patch serviceaccount default \
            -p '{"imagePullSecrets":[{"name":"dockerhub-secret"}]}' \
            --type merge || true

          echo "âœ… dockerhub-secret ensured and attached to default SA in namespace $KUBE_NAMESPACE"

      - name: ğŸ”§ Prepare manifests & (optional) update image refs in files
        run: |
          echo "ğŸ”§ Preparing manifests..."
          mkdir -p /tmp/k8s-updated
          cp -r k8s/* /tmp/k8s-updated/

          # Optional: try to rewrite image lines in YAML if they match known patterns
          # This makes the files nicer, but we will still enforce images via kubectl set image later.
          for svc in june-stt june-tts june-orchestrator june-idp june-web june-dark; do
            # Replace any repo prefix with our registry and set tag
            # Examples handled: image: ozzuworld/<svc>:..., image: docker.io/whatever/<svc>:..., image: <svc>:...
            sed -i -E "s|image:\s*([a-z0-9\./-]*/)?${svc}:[^[:space:]]+|image: ${REGISTRY}/${svc}:${IMAGE_TAG}|g" /tmp/k8s-updated/* 2>/dev/null || true
          done
          echo "âœ… Manifests prepared"

      - name: ğŸ—ï¸ Apply base configuration
        run: |
          echo "ğŸ—ï¸ Applying base Kubernetes resources..."
          if [ -f "/tmp/k8s-updated/namespace.yaml" ]; then
            kubectl apply -f /tmp/k8s-updated/namespace.yaml
          fi
          if [ -f "/tmp/k8s-updated/configmap.yaml" ]; then
            kubectl apply -f /tmp/k8s-updated/configmap.yaml
          fi
          if [ -f "/tmp/k8s-updated/secrets.yaml" ]; then
            kubectl apply -f /tmp/k8s-updated/secrets.yaml
          fi
          echo "â„¹ï¸ Storage is owned by the install script; skipping here."
          if [ -f "k8s-base-config-complete.yaml" ]; then
            kubectl apply -f k8s-base-config-complete.yaml
          fi

      - name: ğŸš€ Deploy services (apply manifests)
        run: |
          echo "ğŸš€ Deploying services..."
          SERVICES_INPUT="${{ github.event.inputs.services }}"
          ALL_SERVICES=("june-stt" "june-tts" "june-orchestrator" "june-idp" "june-web" "june-dark")

          if [ -z "$SERVICES_INPUT" ]; then
            SERVICES_TO_DEPLOY=("${ALL_SERVICES[@]}")
          else
            IFS=',' read -ra SERVICES_TO_DEPLOY <<< "$SERVICES_INPUT"
          fi

          if [ -f "/tmp/k8s-updated/complete-manifests.yaml" ]; then
            kubectl apply -f /tmp/k8s-updated/complete-manifests.yaml
          else
            for service in "${SERVICES_TO_DEPLOY[@]}"; do
              service="$(echo "$service" | xargs)"
              if [ -f "/tmp/k8s-updated/${service}-deployment.yaml" ]; then
                kubectl apply -f "/tmp/k8s-updated/${service}-deployment.yaml"
              else
                echo "âš ï¸ /tmp/k8s-updated/${service}-deployment.yaml not found"
              fi
            done
          fi

      - name: ğŸ–‡ï¸ Enforce image versions on deployments (bullet-proof)
        run: |
          echo "ğŸ–‡ï¸ Forcing images on live deployments to ${REGISTRY}/<svc>:${IMAGE_TAG}"
          set -e
          # Only change images for deployments that actually exist
          for DEP in $(kubectl -n "$KUBE_NAMESPACE" get deploy -o jsonpath='{.items[*].metadata.name}'); do
            case "$DEP" in
              june-stt)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP stt=${REGISTRY}/june-stt:${IMAGE_TAG} --record ;;
              june-tts)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP tts=${REGISTRY}/june-tts:${IMAGE_TAG} --record ;;
              june-orchestrator) kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP orchestrator=${REGISTRY}/june-orchestrator:${IMAGE_TAG} --record ;;
              june-idp)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP idp=${REGISTRY}/june-idp:${IMAGE_TAG} --record ;;
              june-web)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP web=${REGISTRY}/june-web:${IMAGE_TAG} --record || true ;;
              june-dark)         kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP dark=${REGISTRY}/june-dark:${IMAGE_TAG} --record || true ;;
            esac
          done
          echo "âœ… Images enforced"

      - name: ğŸŒ Apply ingress
        run: |
          echo "ğŸŒ Applying ingress configuration..."
          if [ -f "/tmp/k8s-updated/ingress.yaml" ]; then
            kubectl apply -f /tmp/k8s-updated/ingress.yaml
          elif [ -f "k8s-ingress-complete.yaml" ]; then
            kubectl apply -f k8s-ingress-complete.yaml
          else
            echo "âš ï¸ No ingress configuration found"
          fi

      - name: ğŸ”„ Force restart (if requested)
        if: github.event.inputs.force_restart == 'true'
        run: |
          echo "ğŸ”„ Force restarting deployments..."
          kubectl rollout restart deployment -n $KUBE_NAMESPACE

      - name: â³ Wait for deployments
        run: |
          echo "â³ Waiting for deployments to be ready..."
          DEPLOYMENTS=$(kubectl get deployments -n $KUBE_NAMESPACE -o jsonpath='{.items[*].metadata.name}')
          if [ -z "$DEPLOYMENTS" ]; then
            echo "âš ï¸ No deployments found in namespace $KUBE_NAMESPACE"
            exit 0
          fi
          echo "ğŸ“‹ Found deployments: $DEPLOYMENTS"
          for deployment in $DEPLOYMENTS; do
            echo "â³ Waiting for $deployment to be ready..."
            if kubectl rollout status deployment/"$deployment" -n $KUBE_NAMESPACE --timeout=300s; then
              echo "âœ… $deployment is ready"
            else
              echo "âŒ $deployment failed or timed out"
              kubectl describe deployment "$deployment" -n $KUBE_NAMESPACE
              kubectl describe pods -l app="$deployment" -n $KUBE_NAMESPACE
              kubectl logs -l app="$deployment" -n $KUBE_NAMESPACE --tail=50 || true
            fi
          done

      - name: ğŸ” Health check
        run: |
          echo "ğŸ” Performing health checks..."
          sleep 20
          echo "ğŸ“Š Pod Status:"
          kubectl get pods -n $KUBE_NAMESPACE -o wide
          echo "ğŸŒ Service Status:"
          kubectl get services -n $KUBE_NAMESPACE
          echo "ğŸšª Ingress Status:"
          kubectl get ingress -n $KUBE_NAMESPACE || echo "No ingress found"
          FAILED_PODS=$(kubectl get pods -n $KUBE_NAMESPACE --field-selector=status.phase!=Running,status.phase!=Succeeded -o jsonpath='{.items[*].metadata.name}')
          if [ -n "$FAILED_PODS" ]; then
            echo "âŒ Failed pods detected: $FAILED_PODS"
            for pod in $FAILED_PODS; do
              echo "ğŸ” Logs for failed pod $pod:"
              kubectl logs "$pod" -n $KUBE_NAMESPACE --tail=50 || true
              echo "ğŸ“ Description for failed pod $pod:"
              kubectl describe pod "$pod" -n $KUBE_NAMESPACE || true
            done
          else
            echo "âœ… All pods are running successfully!"
          fi

      - name: ğŸ“Š Final deployment status
        if: always()
        run: |
          echo "ğŸ“Š Final deployment status:"
          kubectl get all -n $KUBE_NAMESPACE -o wide || true
          echo ""
          echo "ğŸŒ External Access:"
          EXTERNAL_IP=$(kubectl get service -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Not available")
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null || echo "Not available")
          if [ "$EXTERNAL_IP" != "Not available" ]; then
            echo "ğŸ”— Load Balancer IP: $EXTERNAL_IP"
          elif [ "$NODE_IP" != "Not available" ]; then
            echo "ğŸ”— Node External IP: $NODE_IP"
          else
            echo "ğŸ”— External IP: $(curl -s http://checkip.amazonaws.com/ || echo 'Unable to detect')"
          fi
          echo "âœ… Deployment completed!"
