name: üöÄ June Services Deploy (FIXED - Infrastructure Validation)

on:
  push:
    branches: [ main, develop ]
    paths-ignore: [ 'README.md', 'docs/**', '.gitignore' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      build_images:
        description: 'üî® Build Docker images?'
        required: true
        default: true
        type: boolean
      deploy_services:
        description: 'üöÄ Deploy to Kubernetes?'
        required: true
        default: true
        type: boolean
      services:
        description: 'üì¶ Services to build/deploy (comma-separated, or "all")'
        required: false
        default: 'all'
        type: string

env:
  REGISTRY: docker.io/${{ secrets.DOCKERHUB_USERNAME }}
  NAMESPACE: june-services

permissions:
  contents: read
  packages: write

jobs:
  # ============================================================================
  # SETUP
  # ============================================================================
  
  setup:
    name: üìã Setup Build Matrix
    runs-on: self-hosted
    outputs:
      build_images: ${{ steps.config.outputs.build_images }}
      deploy_services: ${{ steps.config.outputs.deploy_services }}
      services: ${{ steps.config.outputs.services }}
    steps:
      - name: üìù Configure workflow
        id: config
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BUILD="${{ github.event.inputs.build_images }}"
            DEPLOY="${{ github.event.inputs.deploy_services }}"
            SERVICES="${{ github.event.inputs.services }}"
          else
            BUILD="true"
            DEPLOY="true"
            SERVICES="all"
          fi
          
          echo "build_images=$BUILD" >> $GITHUB_OUTPUT
          echo "deploy_services=$DEPLOY" >> $GITHUB_OUTPUT
          echo "services=$SERVICES" >> $GITHUB_OUTPUT
          
          echo "üìã Configuration:"
          echo "  Build images: $BUILD"
          echo "  Deploy services: $DEPLOY"
          echo "  Services: $SERVICES"

  # ============================================================================
  # BUILD IMAGES
  # ============================================================================

  build-stt:
    name: üî® Build june-stt
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'stt'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-stt
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-stt
          file: ./June/services/june-stt/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=stt
          cache-to: type=gha,mode=max,scope=stt
          platforms: linux/amd64

  build-tts:
    name: üî® Build june-tts
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'tts'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-tts
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-tts
          file: ./June/services/june-tts/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=tts
          cache-to: type=gha,mode=max,scope=tts
          platforms: linux/amd64

  build-orchestrator:
    name: üî® Build june-orchestrator
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'orchestrator'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-orchestrator
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-orchestrator
          file: ./June/services/june-orchestrator/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=orchestrator
          cache-to: type=gha,mode=max,scope=orchestrator
          platforms: linux/amd64

  build-idp:
    name: üî® Build june-idp
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'idp'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-idp
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-idp
          file: ./June/services/june-idp/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=idp
          cache-to: type=gha,mode=max,scope=idp
          platforms: linux/amd64

  # ============================================================================
  # DEPLOYMENT (FIXED - Comprehensive Infrastructure Validation)
  # ============================================================================

  deploy:
    name: üöÄ Deploy to Kubernetes
    runs-on: self-hosted
    needs: [setup, build-stt, build-tts, build-orchestrator, build-idp]
    if: |
      always() && 
      needs.setup.outputs.deploy_services == 'true' &&
      (needs.build-stt.result == 'success' || needs.build-stt.result == 'skipped') &&
      (needs.build-tts.result == 'success' || needs.build-tts.result == 'skipped') &&
      (needs.build-orchestrator.result == 'success' || needs.build-orchestrator.result == 'skipped') &&
      (needs.build-idp.result == 'success' || needs.build-idp.result == 'skipped')

    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      # ========================================================================
      # CRITICAL: Infrastructure Validation (FIXED - Comprehensive checks)
      # ========================================================================
      
      - name: üîç Verify Infrastructure Prerequisites
        run: |
          echo "üîç Running comprehensive infrastructure validation..."
          
          ERRORS=0
          WARNINGS=0
          
          # Check cluster
          echo ""
          echo "1Ô∏è‚É£ Checking cluster connectivity..."
          if kubectl cluster-info &>/dev/null; then
            echo "‚úÖ Cluster is accessible"
          else
            echo "‚ùå Cannot connect to Kubernetes cluster!"
            exit 1
          fi
          
          # Check namespace
          echo ""
          echo "2Ô∏è‚É£ Checking namespace..."
          if kubectl get ns $NAMESPACE &>/dev/null; then
            echo "‚úÖ Namespace '$NAMESPACE' exists"
          else
            echo "‚ùå Namespace '$NAMESPACE' doesn't exist!"
            echo "   Run: kubectl create namespace $NAMESPACE"
            ((ERRORS++))
          fi
          
          # Check StorageClass
          echo ""
          echo "3Ô∏è‚É£ Checking StorageClass..."
          if kubectl get sc local-storage &>/dev/null; then
            echo "‚úÖ StorageClass 'local-storage' exists"
          else
            echo "‚ùå StorageClass 'local-storage' doesn't exist!"
            echo "   Run stage2-install-k8s-ubuntu.sh to create it"
            ((ERRORS++))
          fi
          
          # Check PVs
          echo ""
          echo "4Ô∏è‚É£ Checking PersistentVolumes..."
          if kubectl get pv postgresql-pv &>/dev/null; then
            echo "‚úÖ PersistentVolume 'postgresql-pv' exists"
          else
            echo "‚ùå PersistentVolume 'postgresql-pv' doesn't exist!"
            echo "   Run stage2-install-k8s-ubuntu.sh to create it"
            ((ERRORS++))
          fi
          
          # Check storage directories
          echo ""
          echo "5Ô∏è‚É£ Checking storage directories..."
          STORAGE_DIRS=("/opt/june-postgresql-data" "/opt/june-stt-models" "/opt/june-tts-models")
          for dir in "${STORAGE_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              echo "‚úÖ Storage directory $dir exists"
            else
              echo "‚ö†Ô∏è  Storage directory $dir doesn't exist (will be created)"
              mkdir -p "$dir"
              chmod 755 "$dir"
              ((WARNINGS++))
            fi
          done
          
          # Check ingress controller
          echo ""
          echo "6Ô∏è‚É£ Checking ingress controller..."
          if kubectl get pods -n ingress-nginx -l app.kubernetes.io/component=controller 2>/dev/null | grep -q Running; then
            echo "‚úÖ Ingress controller is running"
          else
            echo "‚ùå Ingress controller not running!"
            echo "   Run stage2-install-k8s-ubuntu.sh to install it"
            ((ERRORS++))
          fi
          
          # Check cert-manager
          echo ""
          echo "7Ô∏è‚É£ Checking cert-manager..."
          if kubectl get pods -n cert-manager 2>/dev/null | grep -q Running; then
            echo "‚úÖ cert-manager is running"
          else
            echo "‚ùå cert-manager not running!"
            echo "   Run stage2-install-k8s-ubuntu.sh to install it"
            ((ERRORS++))
          fi
          
          # Check GPU availability (CRITICAL for GPU services)
          echo ""
          echo "8Ô∏è‚É£ Checking GPU availability..."
          GPU_ALLOCATABLE=$(kubectl get nodes -o json | jq -r '.items[].status.allocatable."nvidia.com/gpu" // "0"' | head -1)
          
          if [ "$GPU_ALLOCATABLE" -ge 2 ]; then
            echo "‚úÖ GPU time-slicing active: $GPU_ALLOCATABLE virtual GPUs available"
          elif [ "$GPU_ALLOCATABLE" -eq 1 ]; then
            echo "‚ö†Ô∏è  Only 1 GPU available (time-slicing may not be active)"
            echo "   Expected: 2+ virtual GPUs for time-slicing"
            echo "   Check: kubectl describe nodes | grep nvidia.com/gpu"
            ((WARNINGS++))
          else
            echo "‚ùå No GPUs available!"
            echo "   GPU services (STT, TTS) will fail to schedule!"
            echo "   Run stage2-install-k8s-ubuntu.sh with GPU setup"
            ((ERRORS++))
          fi
          
          # Check node labels
          echo ""
          echo "9Ô∏è‚É£ Checking node labels..."
          GPU_LABELED=$(kubectl get nodes -l gpu=true --no-headers 2>/dev/null | wc -l)
          if [ "$GPU_LABELED" -gt 0 ]; then
            echo "‚úÖ Found $GPU_LABELED node(s) labeled with gpu=true"
          else
            echo "‚ö†Ô∏è  No nodes labeled with gpu=true"
            echo "   Labeling nodes now..."
            kubectl label nodes --all gpu=true --overwrite
            ((WARNINGS++))
          fi
          
          # Check ClusterIssuers
          echo ""
          echo "üîü Checking ClusterIssuers..."
          if kubectl get clusterissuer letsencrypt-prod &>/dev/null; then
            echo "‚úÖ ClusterIssuer 'letsencrypt-prod' exists"
          else
            echo "‚ö†Ô∏è  ClusterIssuer 'letsencrypt-prod' not found"
            echo "   TLS certificates may not work"
            ((WARNINGS++))
          fi
          
          # Summary
          echo ""
          echo "========================================"
          echo "üìä Validation Summary"
          echo "========================================"
          echo "Errors: $ERRORS"
          echo "Warnings: $WARNINGS"
          echo ""
          
          if [ "$ERRORS" -gt 0 ]; then
            echo "‚ùå FAILED: $ERRORS critical error(s) found!"
            echo ""
            echo "‚ö†Ô∏è  DEPLOYMENT BLOCKED"
            echo "   Fix errors above before deploying"
            echo "   Run: sudo ./scripts/k8s Install/stage2-install-k8s-ubuntu.sh"
            exit 1
          elif [ "$WARNINGS" -gt 0 ]; then
            echo "‚ö†Ô∏è  PASSED with $WARNINGS warning(s)"
            echo "   Deployment will continue"
          else
            echo "‚úÖ PASSED: All checks successful!"
          fi

      # ========================================================================
      # Update Application Secrets
      # ========================================================================
      
      - name: üîê Update Application Secrets
        run: |
          echo "üîê Updating application secrets..."
          
          # Create/update June secrets
          kubectl create secret generic june-secrets \
            --from-literal=gemini-api-key='${{ secrets.GEMINI_API_KEY }}' \
            --namespace=$NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Application secrets updated"

      # ========================================================================
      # Deploy PostgreSQL (StatefulSet Only)
      # ========================================================================
      
      - name: üóÑÔ∏è Deploy PostgreSQL
        run: |
          echo "üóÑÔ∏è Deploying PostgreSQL..."
          
          # Deploy StatefulSet (PV already exists from stage2)
          if ! kubectl get statefulset postgresql -n $NAMESPACE &>/dev/null; then
            echo "Creating PostgreSQL StatefulSet..."
            kubectl apply -f k8s/postgresql-deployment.yaml
          else
            echo "‚úÖ PostgreSQL already exists, updating if needed..."
            kubectl apply -f k8s/postgresql-deployment.yaml
          fi
          
          echo "‚è≥ Waiting for PostgreSQL (max 3 minutes)..."
          kubectl wait --for=condition=ready pod -l app=postgresql -n $NAMESPACE --timeout=180s || {
            echo "‚ö†Ô∏è PostgreSQL not ready yet, checking status..."
            kubectl get pods -l app=postgresql -n $NAMESPACE
            kubectl describe pod -l app=postgresql -n $NAMESPACE | tail -20
          }

      # ========================================================================
      # Deploy Application Services (FIXED - No duplicate PVs)
      # ========================================================================
      
      - name: üöÄ Deploy Application Services
        run: |
          echo "üöÄ Deploying June application services..."
          
          # Use complete manifests (which references existing PVs)
          kubectl apply -f k8s/complete-manifests.yaml
          
          echo "‚úÖ Application services deployed"

      # ========================================================================
      # Wait for Deployments (FIXED - Better timeout handling)
      # ========================================================================
      
      - name: ‚è≥ Wait for Deployments
        run: |
          echo "‚è≥ Waiting for deployments to be ready..."
          
          # Function to wait for deployment with better error handling
          wait_for_deployment() {
            local deployment=$1
            local timeout=$2
            local description=$3
            
            echo ""
            echo "Waiting for $description ($deployment)..."
            
            if kubectl rollout status deployment/$deployment -n $NAMESPACE --timeout=${timeout}s; then
              echo "‚úÖ $description is ready"
              return 0
            else
              echo "‚ö†Ô∏è $description taking longer than expected"
              echo "Current status:"
              kubectl get deployment $deployment -n $NAMESPACE
              kubectl get pods -l app=$deployment -n $NAMESPACE
              
              # Check for common issues
              PENDING=$(kubectl get pods -l app=$deployment -n $NAMESPACE --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l)
              if [ "$PENDING" -gt 0 ]; then
                echo "‚ùå Found $PENDING pending pod(s) for $deployment"
                kubectl describe pods -l app=$deployment -n $NAMESPACE | grep -A 10 "Events:"
              fi
              
              return 1
            fi
          }
          
          # Wait for non-GPU services first (shorter timeout)
          wait_for_deployment "june-idp" 300 "Identity Provider (Keycloak)" || true
          wait_for_deployment "june-orchestrator" 180 "Orchestrator" || true
          
          # Wait for GPU services (longer timeout - they download models)
          wait_for_deployment "june-stt" 600 "Speech-to-Text (GPU service)" || true
          wait_for_deployment "june-tts" 600 "Text-to-Speech (GPU service)" || true

      # ========================================================================
      # Deployment Summary (FIXED - Better diagnostics)
      # ========================================================================
      
      - name: üìä Deployment Summary
        if: always()
        run: |
          echo ""
          echo "======================================================"
          echo "üìä Deployment Status Report"
          echo "======================================================"
          echo ""
          
          # Deployments
          echo "üöÄ Deployments:"
          kubectl get deployments -n $NAMESPACE -o wide
          echo ""
          
          # Pods
          echo "üì¶ Pods:"
          kubectl get pods -n $NAMESPACE -o wide
          echo ""
          
          # Check for issues
          echo "üîç Issue Detection:"
          PENDING=$(kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.phase=="Pending") | .metadata.name' | wc -l)
          FAILED=$(kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.phase=="Failed") | .metadata.name' | wc -l)
          CRASH_LOOP=$(kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.containerStatuses[0].state.waiting.reason=="CrashLoopBackOff") | .metadata.name' | wc -l || echo "0")
          IMAGE_PULL=$(kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.containerStatuses[0].state.waiting.reason=="ImagePullBackOff") | .metadata.name' | wc -l || echo "0")
          
          if [ "$PENDING" -gt 0 ]; then
            echo "‚ö†Ô∏è $PENDING pod(s) pending:"
            kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.phase=="Pending") | .metadata.name' | while read pod; do
              echo "  ‚Ä¢ $pod"
              echo "    Reason: $(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="PodScheduled")].message}')"
            done
            echo ""
          fi
          
          if [ "$FAILED" -gt 0 ]; then
            echo "‚ùå $FAILED pod(s) failed:"
            kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.phase=="Failed") | .metadata.name'
            echo ""
          fi
          
          if [ "$CRASH_LOOP" -gt 0 ]; then
            echo "‚ùå $CRASH_LOOP pod(s) in CrashLoopBackOff:"
            kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.containerStatuses[0].state.waiting.reason=="CrashLoopBackOff") | .metadata.name' | while read pod; do
              echo "  ‚Ä¢ $pod"
              echo "    Last 20 log lines:"
              kubectl logs $pod -n $NAMESPACE --tail=20 || echo "    (no logs available)"
            done
            echo ""
          fi
          
          if [ "$IMAGE_PULL" -gt 0 ]; then
            echo "‚ùå $IMAGE_PULL pod(s) with ImagePullBackOff:"
            kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.containerStatuses[0].state.waiting.reason=="ImagePullBackOff") | .metadata.name'
            echo ""
          fi
          
          # GPU Status
          echo "üéÆ GPU Status:"
          GPU_TOTAL=$(kubectl get nodes -o json | jq -r '.items[].status.allocatable."nvidia.com/gpu" // "0"' | head -1)
          GPU_USED=$(kubectl get pods -n $NAMESPACE -o json | jq '[.items[].spec.containers[].resources.requests."nvidia.com/gpu" // "0" | tonumber] | add')
          echo "  Total available: $GPU_TOTAL virtual GPUs"
          echo "  Currently used: $GPU_USED"
          echo "  Remaining: $((GPU_TOTAL - GPU_USED))"
          
          if [ "$GPU_USED" -gt "$GPU_TOTAL" ]; then
            echo "  ‚ö†Ô∏è  WARNING: GPU over-subscription!"
          fi
          echo ""
          
          # Services
          echo "üåê Services:"
          kubectl get services -n $NAMESPACE
          echo ""
          
          # Ingress
          echo "üîê Ingress:"
          kubectl get ingress -n $NAMESPACE
          echo ""
          
          # Certificates
          echo "üîí Certificates:"
          kubectl get certificate -n $NAMESPACE 2>/dev/null || echo "  (no certificates found)"
          echo ""
          
          # Recent Events
          echo "üìã Recent Events (last 10):"
          kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -10
          echo ""
          
          # Summary
          echo "======================================================"
          echo "üìà Summary:"
          TOTAL_DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE --no-headers | wc -l)
          READY_DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE -o json | jq '[.items[] | select(.status.readyReplicas == .spec.replicas)] | length')
          RUNNING_PODS=$(kubectl get pods -n $NAMESPACE --field-selector=status.phase=Running --no-headers | wc -l)
          TOTAL_PODS=$(kubectl get pods -n $NAMESPACE --no-headers | wc -l)
          
          echo "  Deployments: $READY_DEPLOYMENTS/$TOTAL_DEPLOYMENTS ready"
          echo "  Pods: $RUNNING_PODS/$TOTAL_PODS running"
          echo "  Pending: $PENDING"
          echo "  Failed: $FAILED"
          echo "  Issues: $((CRASH_LOOP + IMAGE_PULL))"
          echo "======================================================"
          
          # Exit with error if there are failed pods
          if [ "$FAILED" -gt 0 ] || [ "$IMAGE_PULL" -gt 0 ]; then
            echo ""
            echo "‚ùå Deployment completed with errors!"
            echo "   Check the output above for details"
            exit 1
          elif [ "$PENDING" -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Deployment completed with pending pods"
            echo "   Pods may still be scheduling/starting"
            exit 0
          else
            echo ""
            echo "‚úÖ Deployment successful!"
          fi