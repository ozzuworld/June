name: üöÄ June Services Deploy (Dynamic Domain Support)

on:
  push:
    branches: [ main, develop ]
    paths-ignore: [ 'README.md', 'docs/**', '.gitignore' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      build_images:
        description: 'üî® Build Docker images?'
        required: true
        default: true
        type: boolean
      deploy_services:
        description: 'üöÄ Deploy to Kubernetes?'
        required: true
        default: true
        type: boolean
      services:
        description: 'üì¶ Services to build/deploy (comma-separated, or "all")'
        required: false
        default: 'all'
        type: string

env:
  REGISTRY: docker.io/${{ secrets.DOCKERHUB_USERNAME }}
  NAMESPACE: june-services

permissions:
  contents: read
  packages: write

jobs:
  # ============================================================================
  # SETUP
  # ============================================================================
  
  setup:
    name: üìã Setup Build Matrix
    runs-on: self-hosted
    outputs:
      build_images: ${{ steps.config.outputs.build_images }}
      deploy_services: ${{ steps.config.outputs.deploy_services }}
      services: ${{ steps.config.outputs.services }}
      primary_domain: ${{ steps.domain.outputs.primary_domain }}
      api_domain: ${{ steps.domain.outputs.api_domain }}
      idp_domain: ${{ steps.domain.outputs.idp_domain }}
      stt_domain: ${{ steps.domain.outputs.stt_domain }}
      tts_domain: ${{ steps.domain.outputs.tts_domain }}
      cert_secret_name: ${{ steps.domain.outputs.cert_secret_name }}
    steps:
      - name: üìù Configure workflow
        id: config
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BUILD="${{ github.event.inputs.build_images }}"
            DEPLOY="${{ github.event.inputs.deploy_services }}"
            SERVICES="${{ github.event.inputs.services }}"
          else
            BUILD="true"
            DEPLOY="true"
            SERVICES="all"
          fi
          
          # Set GitHub outputs first
          echo "build_images=$BUILD" >> $GITHUB_OUTPUT
          echo "deploy_services=$DEPLOY" >> $GITHUB_OUTPUT
          echo "services=$SERVICES" >> $GITHUB_OUTPUT
          
          echo "üìã Configuration:"
          echo "  Build images: $BUILD"
          echo "  Deploy services: $DEPLOY"
          echo "  Services: $SERVICES"
      
      - name: üåê Load Domain Configuration
        id: domain
        run: |
          DOMAIN_CONFIG="/root/.june-config/domain-config.env"
          
          if [ -f "$DOMAIN_CONFIG" ]; then
            echo "‚úÖ Found domain configuration"
            source "$DOMAIN_CONFIG"
            
            echo "primary_domain=$PRIMARY_DOMAIN" >> $GITHUB_OUTPUT
            echo "api_domain=$API_DOMAIN" >> $GITHUB_OUTPUT
            echo "idp_domain=$IDP_DOMAIN" >> $GITHUB_OUTPUT
            echo "stt_domain=$STT_DOMAIN" >> $GITHUB_OUTPUT
            echo "tts_domain=$TTS_DOMAIN" >> $GITHUB_OUTPUT
            echo "cert_secret_name=$CERT_SECRET_NAME" >> $GITHUB_OUTPUT
            
            echo "üåê Domain Configuration:"
            echo "  Primary: $PRIMARY_DOMAIN"
            echo "  API: $API_DOMAIN"
            echo "  IDP: $IDP_DOMAIN"
            echo "  STT: $STT_DOMAIN"
            echo "  TTS: $TTS_DOMAIN"
            echo "  Cert Secret: $CERT_SECRET_NAME"
          else
            echo "‚ö†Ô∏è  No domain configuration found, using defaults"
            echo "primary_domain=allsafe.world" >> $GITHUB_OUTPUT
            echo "api_domain=api.allsafe.world" >> $GITHUB_OUTPUT
            echo "idp_domain=idp.allsafe.world" >> $GITHUB_OUTPUT
            echo "stt_domain=stt.allsafe.world" >> $GITHUB_OUTPUT
            echo "tts_domain=tts.allsafe.world" >> $GITHUB_OUTPUT
            echo "cert_secret_name=allsafe-wildcard-tls" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # BUILD IMAGES
  # ============================================================================

  build-stt:
    name: üî® Build june-stt
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'stt'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-stt
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-stt
          file: ./June/services/june-stt/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=stt
          cache-to: type=gha,mode=max,scope=stt
          platforms: linux/amd64

  build-tts:
    name: üî® Build june-tts
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'tts'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-tts
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-tts
          file: ./June/services/june-tts/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=tts
          cache-to: type=gha,mode=max,scope=tts
          platforms: linux/amd64

  build-orchestrator:
    name: üî® Build june-orchestrator
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'orchestrator'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-orchestrator
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-orchestrator
          file: ./June/services/june-orchestrator/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=orchestrator
          cache-to: type=gha,mode=max,scope=orchestrator
          platforms: linux/amd64

  build-idp:
    name: üî® Build june-idp
    runs-on: self-hosted
    needs: setup
    if: needs.setup.outputs.build_images == 'true' && (needs.setup.outputs.services == 'all' || contains(needs.setup.outputs.services, 'idp'))
    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/june-idp
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./June/services/june-idp
          file: ./June/services/june-idp/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=idp
          cache-to: type=gha,mode=max,scope=idp
          platforms: linux/amd64

  # ============================================================================
  # DEPLOYMENT (WITH DYNAMIC DOMAIN CONFIGURATION + GEMINI API KEY)
  # ============================================================================

  deploy:
    name: üöÄ Deploy to Kubernetes
    runs-on: self-hosted
    needs: [setup, build-stt, build-tts, build-orchestrator, build-idp]
    if: |
      always() && 
      needs.setup.outputs.deploy_services == 'true' &&
      (needs.build-stt.result == 'success' || needs.build-stt.result == 'skipped') &&
      (needs.build-tts.result == 'success' || needs.build-tts.result == 'skipped') &&
      (needs.build-orchestrator.result == 'success' || needs.build-orchestrator.result == 'skipped') &&
      (needs.build-idp.result == 'success' || needs.build-idp.result == 'skipped')

    steps:
      - name: üì¶ Checkout
        uses: actions/checkout@v4

      # ========================================================================
      # Infrastructure Validation
      # ========================================================================
      
      - name: üîç Verify Infrastructure Prerequisites
        run: |
          echo "üîç Running comprehensive infrastructure validation..."
          
          ERRORS=0
          WARNINGS=0
          
          echo ""
          echo "1Ô∏è‚É£ Checking cluster connectivity..."
          if kubectl cluster-info &>/dev/null; then
            echo "‚úÖ Cluster is accessible"
          else
            echo "‚ùå Cannot connect to Kubernetes cluster!"
            exit 1
          fi
          
          echo ""
          echo "2Ô∏è‚É£ Checking namespace..."
          if kubectl get ns $NAMESPACE &>/dev/null; then
            echo "‚úÖ Namespace '$NAMESPACE' exists"
          else
            echo "‚ùå Namespace '$NAMESPACE' doesn't exist!"
            ((ERRORS++))
          fi
          
          echo ""
          echo "3Ô∏è‚É£ Checking StorageClass..."
          if kubectl get sc local-storage &>/dev/null; then
            echo "‚úÖ StorageClass 'local-storage' exists"
          else
            echo "‚ùå StorageClass 'local-storage' doesn't exist!"
            ((ERRORS++))
          fi
          
          echo ""
          echo "4Ô∏è‚É£ Checking PersistentVolumes..."
          if kubectl get pv postgresql-pv &>/dev/null; then
            echo "‚úÖ PersistentVolume 'postgresql-pv' exists"
          else
            echo "‚ùå PersistentVolume 'postgresql-pv' doesn't exist!"
            ((ERRORS++))
          fi
          
          echo ""
          echo "5Ô∏è‚É£ Checking storage directories..."
          STORAGE_DIRS=("/opt/june-postgresql-data" "/opt/june-stt-models" "/opt/june-tts-models")
          for dir in "${STORAGE_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              echo "‚úÖ Storage directory $dir exists"
            else
              echo "‚ö†Ô∏è  Storage directory $dir doesn't exist (will be created)"
              mkdir -p "$dir"
              chmod 755 "$dir"
              ((WARNINGS++))
            fi
          done
          
          echo ""
          echo "6Ô∏è‚É£ Checking ingress controller..."
          if kubectl get pods -n ingress-nginx -l app.kubernetes.io/component=controller 2>/dev/null | grep -q Running; then
            echo "‚úÖ Ingress controller is running"
          else
            echo "‚ùå Ingress controller not running!"
            ((ERRORS++))
          fi
          
          echo ""
          echo "7Ô∏è‚É£ Checking cert-manager..."
          if kubectl get pods -n cert-manager 2>/dev/null | grep -q Running; then
            echo "‚úÖ cert-manager is running"
          else
            echo "‚ùå cert-manager not running!"
            ((ERRORS++))
          fi
          
          echo ""
          echo "8Ô∏è‚É£ Checking GPU availability..."
          GPU_ALLOCATABLE=$(kubectl get nodes -o json | jq -r '.items[].status.allocatable."nvidia.com/gpu" // "0"' | head -1)
          
          if [ "$GPU_ALLOCATABLE" -ge 2 ]; then
            echo "‚úÖ GPU time-slicing active: $GPU_ALLOCATABLE virtual GPUs available"
          elif [ "$GPU_ALLOCATABLE" -eq 1 ]; then
            echo "‚ö†Ô∏è  Only 1 GPU available (time-slicing may not be active)"
            ((WARNINGS++))
          else
            echo "‚ùå No GPUs available!"
            ((ERRORS++))
          fi
          
          echo ""
          echo "9Ô∏è‚É£ Checking node labels..."
          GPU_LABELED=$(kubectl get nodes -l gpu=true --no-headers 2>/dev/null | wc -l)
          if [ "$GPU_LABELED" -gt 0 ]; then
            echo "‚úÖ Found $GPU_LABELED node(s) labeled with gpu=true"
          else
            echo "‚ö†Ô∏è  No nodes labeled with gpu=true"
            kubectl label nodes --all gpu=true --overwrite
            ((WARNINGS++))
          fi
          
          echo ""
          echo "üîü Checking domain configuration..."
          if [ -f "/root/.june-config/domain-config.env" ]; then
            echo "‚úÖ Domain configuration exists"
            source /root/.june-config/domain-config.env
            echo "   Primary Domain: $PRIMARY_DOMAIN"
          else
            echo "‚ö†Ô∏è  No domain configuration found (using defaults)"
            ((WARNINGS++))
          fi
          
          echo ""
          echo "========================================"
          echo "üìä Validation Summary"
          echo "========================================"
          echo "Errors: $ERRORS"
          echo "Warnings: $WARNINGS"
          echo ""
          
          if [ "$ERRORS" -gt 0 ]; then
            echo "‚ùå FAILED: $ERRORS critical error(s) found!"
            echo "   Run: sudo ./scripts/install-k8s/stage2-install-k8s-ubuntu.sh"
            exit 1
          elif [ "$WARNINGS" -gt 0 ]; then
            echo "‚ö†Ô∏è  PASSED with $WARNINGS warning(s)"
          else
            echo "‚úÖ PASSED: All checks successful!"
          fi

      # ========================================================================
      # Generate Manifest with Domain Configuration
      # ========================================================================
      
      - name: üåê Generate Deployment Manifest with Domain Config
        run: |
          echo "üåê Generating manifest with domain configuration..."
          
          # Load domain config
          if [ -f "/root/.june-config/domain-config.env" ]; then
            source /root/.june-config/domain-config.env
            echo "‚úÖ Using configured domains:"
            echo "   Primary: $PRIMARY_DOMAIN"
            echo "   API: $API_DOMAIN"
            echo "   IDP: $IDP_DOMAIN"
            echo "   STT: $STT_DOMAIN"
            echo "   TTS: $TTS_DOMAIN"
            echo "   Cert Secret: $CERT_SECRET_NAME"
          else
            echo "‚ö†Ô∏è  No domain config found, using defaults"
            PRIMARY_DOMAIN="allsafe.world"
            API_DOMAIN="api.allsafe.world"
            IDP_DOMAIN="idp.allsafe.world"
            STT_DOMAIN="stt.allsafe.world"
            TTS_DOMAIN="tts.allsafe.world"
            CERT_SECRET_NAME="allsafe-wildcard-tls"
          fi
          
          # Create a temporary manifest with domain substitution
          cp k8s/complete-manifests.yaml /tmp/deployment-manifest.yaml
          
          # Replace domain placeholders
          sed -i "s/KC_HOSTNAME_VALUE/${IDP_DOMAIN}/g" /tmp/deployment-manifest.yaml || true
          sed -i "s/allsafe-wildcard-tls/${CERT_SECRET_NAME}/g" /tmp/deployment-manifest.yaml
          sed -i "s/\*.allsafe.world/*.${PRIMARY_DOMAIN}/g" /tmp/deployment-manifest.yaml
          sed -i "s/api.allsafe.world/${API_DOMAIN}/g" /tmp/deployment-manifest.yaml
          sed -i "s/idp.allsafe.world/${IDP_DOMAIN}/g" /tmp/deployment-manifest.yaml
          sed -i "s/stt.allsafe.world/${STT_DOMAIN}/g" /tmp/deployment-manifest.yaml
          sed -i "s/tts.allsafe.world/${TTS_DOMAIN}/g" /tmp/deployment-manifest.yaml
          
          echo "‚úÖ Manifest generated with configured domains"

      # ========================================================================
      # Update Application Secrets (INCLUDING GEMINI API KEY)
      # ========================================================================
      
      - name: üîê Update Application Secrets
        run: |
          echo "üîê Updating application secrets with Gemini API key..."
          
          # Verify we have the Gemini API key from GitHub secrets
          if [ -z "${{ secrets.GEMINI_API_KEY }}" ]; then
            echo "‚ùå ERROR: GEMINI_API_KEY not set in GitHub secrets!"
            echo ""
            echo "To fix this:"
            echo "  1. Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "  2. Click 'New repository secret'"
            echo "  3. Name: GEMINI_API_KEY"
            echo "  4. Value: Your actual Gemini API key from https://makersuite.google.com/app/apikey"
            echo "  5. Click 'Add secret'"
            echo ""
            exit 1
          fi
          
          # Validate key length (basic check)
          KEY_LENGTH=$(echo -n "${{ secrets.GEMINI_API_KEY }}" | wc -c)
          if [ "$KEY_LENGTH" -lt 20 ]; then
            echo "‚ö†Ô∏è  WARNING: Gemini API key seems too short ($KEY_LENGTH characters)"
            echo "   Please verify your key is correct"
          else
            echo "‚úÖ Gemini API key validated ($KEY_LENGTH characters)"
          fi
          
          # Update the shared june-secrets (used by orchestrator)
          kubectl create secret generic june-secrets \
            --from-literal=gemini-api-key='${{ secrets.GEMINI_API_KEY }}' \
            --from-literal=keycloak-client-secret='PLACEHOLDER' \
            --namespace=$NAMESPACE \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Application secrets updated with Gemini API key"
          
          # Verify the secret was created correctly
          echo ""
          echo "üîç Verifying secret..."
          if kubectl get secret june-secrets -n $NAMESPACE &>/dev/null; then
            echo "‚úÖ june-secrets exists"
            
            # Check if gemini-api-key is present (without showing the value)
            STORED_KEY=$(kubectl get secret june-secrets -n $NAMESPACE -o jsonpath='{.data.gemini-api-key}' | base64 -d 2>/dev/null || echo "")
            STORED_LENGTH=${#STORED_KEY}
            
            if [ "$STORED_LENGTH" -ge 20 ]; then
              echo "‚úÖ gemini-api-key is present in secret ($STORED_LENGTH characters)"
              echo "   Masked key: ${STORED_KEY:0:6}...${STORED_KEY: -4}"
            else
              echo "‚ùå gemini-api-key is missing or invalid (length: $STORED_LENGTH)!"
              exit 1
            fi
          else
            echo "‚ùå june-secrets not found!"
            exit 1
          fi

      # ========================================================================
      # Deploy All Services
      # ========================================================================
      
      - name: üöÄ Deploy All Services
        run: |
          echo "üöÄ Deploying all June services..."
          
          # Apply the generated manifest with domain config
          kubectl apply -f /tmp/deployment-manifest.yaml
          
          echo "‚úÖ All services deployed"
          echo ""
          
          # Wait for PostgreSQL
          echo "‚è≥ Waiting for PostgreSQL to be ready..."
          kubectl wait --for=condition=ready pod -l app=postgresql -n $NAMESPACE --timeout=180s || {
            echo "‚ö†Ô∏è PostgreSQL not ready yet, checking status..."
            kubectl get pods -l app=postgresql -n $NAMESPACE
            kubectl describe pod -l app=postgresql -n $NAMESPACE | tail -20
          }
          
          echo "‚úÖ PostgreSQL is ready"

      # ========================================================================
      # Wait for Deployments
      # ========================================================================
      
      - name: ‚è≥ Wait for Deployments
        run: |
          echo "‚è≥ Waiting for deployments to be ready..."
          
          wait_for_deployment() {
            local deployment=$1
            local timeout=$2
            local description=$3
            
            echo ""
            echo "Waiting for $description ($deployment)..."
            
            if kubectl rollout status deployment/$deployment -n $NAMESPACE --timeout=${timeout}s; then
              echo "‚úÖ $description is ready"
              return 0
            else
              echo "‚ö†Ô∏è $description taking longer than expected"
              kubectl get deployment $deployment -n $NAMESPACE
              kubectl get pods -l app=$deployment -n $NAMESPACE
              
              PENDING=$(kubectl get pods -l app=$deployment -n $NAMESPACE --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l)
              if [ "$PENDING" -gt 0 ]; then
                echo "‚ùå Found $PENDING pending pod(s) for $deployment"
                kubectl describe pods -l app=$deployment -n $NAMESPACE | grep -A 10 "Events:"
              fi
              
              return 1
            fi
          }
          
          # Wait for non-GPU services
          wait_for_deployment "june-idp" 300 "Identity Provider (Keycloak)" || true
          wait_for_deployment "june-orchestrator" 180 "Orchestrator" || true
          
          # Wait for GPU services
          wait_for_deployment "june-stt" 600 "Speech-to-Text (GPU service)" || true
          wait_for_deployment "june-tts" 600 "Text-to-Speech (GPU service)" || true

      # ========================================================================
      # Verify Gemini API Key in Orchestrator
      # ========================================================================
      
      - name: ‚úÖ Verify Gemini API Key Configuration
        run: |
          echo "üîç Verifying Gemini API key in june-orchestrator..."
          echo ""
          
          # Wait a bit for orchestrator to start
          sleep 10
          
          # Check orchestrator logs for Gemini initialization
          echo "Checking orchestrator logs..."
          LOGS=$(kubectl logs -l app=june-orchestrator -n $NAMESPACE --tail=100 2>/dev/null || echo "")
          
          if echo "$LOGS" | grep -q "‚úÖ Gemini AI service ready"; then
            echo "‚úÖ SUCCESS: Gemini AI service is ready and configured!"
            echo ""
            echo "   Gemini API key is working correctly"
          elif echo "$LOGS" | grep -q "‚ùå GEMINI_API_KEY not set"; then
            echo "‚ùå ERROR: Gemini API key not detected in orchestrator!"
            echo ""
            echo "Recent logs:"
            echo "$LOGS" | tail -20
            echo ""
            echo "This deployment will continue, but orchestrator won't work properly."
            echo "Please check GitHub secrets configuration."
          elif echo "$LOGS" | grep -q "‚ö†Ô∏è Gemini AI service not ready"; then
            echo "‚ö†Ô∏è  WARNING: Gemini initialization in progress or failed"
            echo ""
            echo "Recent logs:"
            echo "$LOGS" | tail -20
          else
            echo "‚ö†Ô∏è  Could not determine Gemini status from logs"
            echo ""
            echo "Recent logs:"
            echo "$LOGS" | tail -20
          fi
          
          echo ""
          echo "üìã Full orchestrator status:"
          kubectl describe pod -l app=june-orchestrator -n $NAMESPACE | grep -A 5 "Environment:"

      # ========================================================================
      # Deployment Summary
      # ========================================================================
      
      - name: üìä Deployment Summary
        if: always()
        run: |
          # Load domain config for summary
          if [ -f "/root/.june-config/domain-config.env" ]; then
            source /root/.june-config/domain-config.env
          else
            PRIMARY_DOMAIN="allsafe.world"
            API_DOMAIN="api.allsafe.world"
            IDP_DOMAIN="idp.allsafe.world"
            STT_DOMAIN="stt.allsafe.world"
            TTS_DOMAIN="tts.allsafe.world"
          fi
          
          echo ""
          echo "======================================================"
          echo "üìä Deployment Status Report"
          echo "======================================================"
          echo ""
          
          echo "üåê Deployed Domains:"
          echo "  API: https://${API_DOMAIN}"
          echo "  IDP: https://${IDP_DOMAIN}"
          echo "  STT: https://${STT_DOMAIN}"
          echo "  TTS: https://${TTS_DOMAIN}"
          echo ""
          
          echo "üîë API Keys Status:"
          GEMINI_CONFIGURED=$(kubectl get secret june-secrets -n $NAMESPACE -o jsonpath='{.data.gemini-api-key}' 2>/dev/null | base64 -d 2>/dev/null | wc -c)
          if [ "$GEMINI_CONFIGURED" -ge 20 ]; then
            echo "  ‚úÖ Gemini API Key: Configured ($GEMINI_CONFIGURED chars)"
          else
            echo "  ‚ùå Gemini API Key: Missing or invalid"
          fi
          echo ""
          
          echo "üöÄ Deployments:"
          kubectl get deployments -n $NAMESPACE -o wide
          echo ""
          
          echo "üì¶ Pods:"
          kubectl get pods -n $NAMESPACE -o wide
          echo ""
          
          echo "üîç Issue Detection:"
          PENDING=$(kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.phase=="Pending") | .metadata.name' | wc -l)
          FAILED=$(kubectl get pods -n $NAMESPACE -o json | jq -r '.items[] | select(.status.phase=="Failed") | .metadata.name' | wc -l)
          
          if [ "$PENDING" -gt 0 ]; then
            echo "‚ö†Ô∏è $PENDING pod(s) pending"
          fi
          
          if [ "$FAILED" -gt 0 ]; then
            echo "‚ùå $FAILED pod(s) failed"
            exit 1
          fi
          
          echo ""
          echo "üéÆ GPU Status:"
          GPU_TOTAL=$(kubectl get nodes -o json | jq -r '.items[].status.allocatable."nvidia.com/gpu" // "0"' | head -1)
          GPU_USED=$(kubectl get pods -n $NAMESPACE -o json | jq '[.items[].spec.containers[].resources.requests."nvidia.com/gpu" // "0" | tonumber] | add')
          echo "  Total available: $GPU_TOTAL virtual GPUs"
          echo "  Currently used: $GPU_USED"
          echo "  Remaining: $((GPU_TOTAL - GPU_USED))"
          echo ""
          
          echo "üåê Services:"
          kubectl get services -n $NAMESPACE
          echo ""
          
          echo "üîê Ingress:"
          kubectl get ingress -n $NAMESPACE
          echo ""
          
          echo "======================================================"
          TOTAL_DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE --no-headers | wc -l)
          READY_DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE -o json | jq '[.items[] | select(.status.readyReplicas == .spec.replicas)] | length')
          RUNNING_PODS=$(kubectl get pods -n $NAMESPACE --field-selector=status.phase=Running --no-headers | wc -l)
          TOTAL_PODS=$(kubectl get pods -n $NAMESPACE --no-headers | wc -l)
          
          echo "üìà Summary:"
          echo "  Deployments: $READY_DEPLOYMENTS/$TOTAL_DEPLOYMENTS ready"
          echo "  Pods: $RUNNING_PODS/$TOTAL_PODS running"
          echo "  Pending: $PENDING"
          echo "  Failed: $FAILED"
          echo "======================================================"
          
          if [ "$FAILED" -gt 0 ]; then
            echo ""
            echo "‚ùå Deployment completed with errors!"
            exit 1
          elif [ "$PENDING" -gt 0 ]; then
            echo ""
            echo "‚ö†Ô∏è  Deployment completed with pending pods"
          else
            echo ""
            echo "‚úÖ Deployment successful!"
          fi
