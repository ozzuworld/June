name: üöÄ Complete June Services CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore: [ 'README.md', 'docs/**', '.gitignore' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
        default: 'latest'
        type: string
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options: [production, staging, development]
      services:
        description: 'Services to deploy (comma-separated, empty for all)'
        required: false
        default: ''
        type: string
      force_restart:
        description: 'Force restart deployments'
        required: false
        default: false
        type: boolean
      build_images:
        description: 'Build and push Docker images'
        required: false
        default: true
        type: boolean

env:
  REGISTRY: docker.io/${{ secrets.DOCKERHUB_USERNAME }}
  KUBE_NAMESPACE: june-services
  IMAGE_TAG: ${{ github.event.inputs.image_tag || github.sha }}

permissions:
  contents: read
  packages: write

jobs:
  build-and-push:
    name: üî® Build & Push Images
    runs-on: self-hosted
    if: github.event.inputs.build_images != 'false'
    strategy:
      fail-fast: false
      matrix:
        service: [june-stt, june-tts, june-orchestrator, june-idp, june-web, june-dark]
    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üìù Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ env.IMAGE_TAG }}

      - name: üèóÔ∏è Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  deploy:
    name: üöÄ Deploy to K8s
    runs-on: self-hosted
    needs: build-and-push
    if: always() && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')

    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4

      - name: üîç Verify k8s manifest files
        run: |
          set -e
          echo "üîç Verifying k8s manifest files..."
          ls -la k8s || true
          test -f k8s/namespace.yaml || echo "‚ö†Ô∏è k8s/namespace.yaml not found; will create namespace with kubectl"

      - name: üîç Verify Kubernetes connection
        run: |
          echo "üîç Testing Kubernetes connection..."
          kubectl cluster-info
          kubectl get nodes -o wide

      # ============================================================================
      # ‚úÖ GPU SETUP (NEW CRITICAL SECTION)
      # ============================================================================
      - name: üéÆ Configure GPU Support
        run: |
          echo "üéÆ Configuring GPU node labels and checking GPU Operator..."
          
          # 1. Label all nodes with gpu=true
          echo "üè∑Ô∏è  Labeling nodes for GPU workloads..."
          for node in $(kubectl get nodes -o name); do
            kubectl label $node gpu=true --overwrite
            echo "‚úÖ Labeled: $node"
          done
          
          # 2. Check if GPU Operator is installed
          echo ""
          echo "üîç Checking GPU Operator status..."
          if kubectl get namespace gpu-operator &>/dev/null; then
            echo "‚úÖ GPU Operator namespace exists"
            
            # Show GPU Operator pods
            echo "üìä GPU Operator pods:"
            kubectl get pods -n gpu-operator
            
            # Wait for critical GPU Operator components
            echo ""
            echo "‚è≥ Waiting for GPU Operator components..."
            
            # Wait for device plugin (critical for GPU scheduling)
            if kubectl get daemonset -n gpu-operator nvidia-device-plugin-daemonset &>/dev/null; then
              echo "‚è≥ Waiting for device plugin..."
              kubectl rollout status daemonset/nvidia-device-plugin-daemonset -n gpu-operator --timeout=300s || {
                echo "‚ö†Ô∏è Device plugin taking longer than expected"
              }
            fi
            
            # Wait for container toolkit (critical for GPU runtime)
            if kubectl get daemonset -n gpu-operator nvidia-container-toolkit-daemonset &>/dev/null; then
              echo "‚è≥ Waiting for container toolkit..."
              kubectl rollout status daemonset/nvidia-container-toolkit-daemonset -n gpu-operator --timeout=300s || {
                echo "‚ö†Ô∏è Container toolkit taking longer than expected"
              }
            fi
            
          else
            echo "‚ö†Ô∏è GPU Operator namespace not found"
            echo "   GPU Operator should be installed by stage2-install-k8s-ubuntu.sh"
            echo "   Continuing anyway - GPU pods may fail to schedule"
          fi
          
          # 3. Check for GPU resources on nodes
          echo ""
          echo "üîç Checking GPU resources on nodes..."
          sleep 15  # Give time for resources to register
          
          GPU_AVAILABLE=false
          for i in {1..12}; do
            GPU_COUNT=$(kubectl get nodes -o json | jq -r '.items[].status.capacity."nvidia.com/gpu"' 2>/dev/null | grep -v "null" | head -1)
            
            if [ -n "$GPU_COUNT" ] && [ "$GPU_COUNT" != "null" ]; then
              echo "‚úÖ GPU resources detected: $GPU_COUNT GPU(s) per node"
              GPU_AVAILABLE=true
              break
            fi
            
            echo "‚è≥ Waiting for GPU resources to be advertised... (attempt $i/12)"
            sleep 10
          done
          
          if [ "$GPU_AVAILABLE" = false ]; then
            echo "‚ö†Ô∏è WARNING: No GPU resources detected after 2 minutes"
            echo "   GPU pods (june-stt, june-tts) may remain in Pending state"
            echo "   Check GPU Operator logs: kubectl logs -n gpu-operator -l app=nvidia-device-plugin-daemonset"
          fi
          
          # 4. Show detailed GPU status
          echo ""
          echo "üìä Node GPU Status:"
          kubectl describe nodes | grep -A 10 "Capacity:" | grep -E "(nvidia.com/gpu|Allocatable)" || {
            echo "‚ùå No nvidia.com/gpu resources found on nodes"
          }
          
          echo ""
          echo "‚úÖ GPU configuration complete"

      # ============================================================================
      # ‚úÖ TLS/Certificate Setup
      # ============================================================================
      - name: üîê Setup cert-manager and Let's Encrypt
        run: |
          echo "üîê Setting up TLS certificates with cert-manager..."
          
          # Check if cert-manager is already installed
          if ! kubectl get namespace cert-manager &>/dev/null; then
            echo "üì¶ Installing cert-manager..."
            
            # Install CRDs
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.crds.yaml
            
            # Create namespace
            kubectl create namespace cert-manager
            
            # Install cert-manager
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
            
            # Wait for cert-manager to be ready
            echo "‚è≥ Waiting for cert-manager pods to be ready..."
            kubectl wait --for=condition=ready pod \
              -l app.kubernetes.io/instance=cert-manager \
              -n cert-manager \
              --timeout=180s || {
              echo "‚ö†Ô∏è cert-manager taking longer than expected, checking status..."
              kubectl get pods -n cert-manager
            }
            
            echo "‚úÖ cert-manager installed successfully"
          else
            echo "‚úÖ cert-manager already installed"
          fi
          
          # Create or update ClusterIssuers
          echo "üîß Creating/updating Let's Encrypt issuers..."
          
          # Production issuer
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: ${{ secrets.LETSENCRYPT_EMAIL }}
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
          
          # Staging issuer (for testing)
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-staging
          spec:
            acme:
              server: https://acme-staging-v02.api.letsencrypt.org/directory
              email: ${{ secrets.LETSENCRYPT_EMAIL }}
              privateKeySecretRef:
                name: letsencrypt-staging
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
          
          echo "‚úÖ Let's Encrypt issuers configured"
          kubectl get clusterissuer

      # ============================================================================
      # ‚úÖ Ingress Controller Setup
      # ============================================================================
      - name: üåê Setup/Verify Ingress Controller
        run: |
          echo "üåê Setting up ingress-nginx controller..."
          
          # Function to detect environment
          detect_environment() {
            echo "üîç Detecting environment..."
            
            if curl -s --max-time 2 http://169.254.169.254/latest/meta-data/ >/dev/null 2>&1; then
              echo "   ‚úÖ AWS detected"
              return 0  # Cloud
            elif curl -s --max-time 2 -H "Metadata-Flavor: Google" http://metadata.google.internal >/dev/null 2>&1; then
              echo "   ‚úÖ GCP detected"
              return 0  # Cloud
            elif curl -s --max-time 2 -H "Metadata: true" http://169.254.169.254/metadata/instance >/dev/null 2>&1; then
              echo "   ‚úÖ Azure detected"
              return 0  # Cloud
            else
              echo "   üì¶ Bare metal/VM detected"
              return 1  # Bare metal
            fi
          }
          
          # Check if ingress-nginx namespace exists
          if ! kubectl get namespace ingress-nginx >/dev/null 2>&1; then
            echo "üì¶ Installing ingress-nginx..."
            
            if detect_environment; then
              echo "‚òÅÔ∏è  Installing for cloud environment..."
              kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml
            else
              echo "üîß Installing for bare metal/VM environment..."
              kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/baremetal/deploy.yaml
              
              echo "‚è≥ Waiting for initial deployment..."
              sleep 15
              
              echo "üîß Enabling hostNetwork for bare metal..."
              kubectl patch deployment ingress-nginx-controller \
                -n ingress-nginx \
                --type='json' \
                -p='[
                  {"op": "add", "path": "/spec/template/spec/hostNetwork", "value": true},
                  {"op": "add", "path": "/spec/template/spec/dnsPolicy", "value": "ClusterFirstWithHostNet"}
                ]'
            fi
          else
            echo "‚úÖ ingress-nginx namespace already exists"
            
            # Verify and fix hostNetwork for bare metal if needed
            if ! detect_environment; then
              HOST_NET=$(kubectl get deployment ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.template.spec.hostNetwork}' 2>/dev/null || echo "false")
              
              if [ "$HOST_NET" != "true" ]; then
                echo "üîß Detected bare metal environment - enabling hostNetwork..."
                kubectl patch deployment ingress-nginx-controller \
                  -n ingress-nginx \
                  --type='json' \
                  -p='[
                    {"op": "add", "path": "/spec/template/spec/hostNetwork", "value": true},
                    {"op": "add", "path": "/spec/template/spec/dnsPolicy", "value": "ClusterFirstWithHostNet"}
                  ]'
              else
                echo "‚úÖ hostNetwork already enabled"
              fi
            fi
          fi
          
          # Wait for controller to be ready
          echo "‚è≥ Waiting for ingress controller to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=300s || {
            echo "‚ö†Ô∏è  Controller taking longer than expected, checking status..."
            kubectl get pods -n ingress-nginx
            kubectl describe pods -n ingress-nginx -l app.kubernetes.io/component=controller | tail -50
          }
          
          echo "‚úÖ Ingress controller ready"
          echo "üìä Ingress status:"
          kubectl get pods,svc -n ingress-nginx

      - name: üèóÔ∏è Create/Apply Namespace FIRST
        run: |
          if [ -f k8s/namespace.yaml ]; then
            echo "üèóÔ∏è Applying k8s/namespace.yaml..."
            kubectl apply -f k8s/namespace.yaml
          else
            echo "üèóÔ∏è Creating namespace $KUBE_NAMESPACE..."
            kubectl get ns "$KUBE_NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$KUBE_NAMESPACE"
          fi
          echo "üìä Namespace status:"
          kubectl get ns "$KUBE_NAMESPACE" -o yaml | sed -n '1,80p'

      - name: üîê Create/Update Docker Registry Secret
        run: |
          kubectl create secret docker-registry dockerhub-secret \
            --docker-server=docker.io \
            --docker-username='${{ secrets.DOCKERHUB_USERNAME }}' \
            --docker-password='${{ secrets.DOCKERHUB_TOKEN }}' \
            --docker-email='${{ secrets.DOCKERHUB_EMAIL }}' \
            --namespace="$KUBE_NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -
          kubectl -n "$KUBE_NAMESPACE" patch serviceaccount default \
            -p '{"imagePullSecrets":[{"name":"dockerhub-secret"}]}' \
            --type merge || true

      - name: üîß Prepare manifests and update image tags
        run: |
          set -e
          echo "üìÅ Copying k8s/* to /tmp/k8s-updated and updating image tags to: $IMAGE_TAG"
          mkdir -p /tmp/k8s-updated
          cp -r k8s/* /tmp/k8s-updated/ || true
          for service in june-stt june-tts june-orchestrator june-idp june-web june-dark; do
            if [ -f "/tmp/k8s-updated/${service}-deployment.yaml" ]; then
              sed -i "s|image: $REGISTRY/${service}:.*|image: $REGISTRY/${service}:$IMAGE_TAG|g" "/tmp/k8s-updated/${service}-deployment.yaml" || true
            elif [ -f "/tmp/k8s-updated/complete-manifests.yaml" ]; then
              sed -i "s|image: ozzuworld/${service}:.*|image: $REGISTRY/${service}:$IMAGE_TAG|g" "/tmp/k8s-updated/complete-manifests.yaml" || true
            fi
          done

      - name: üßΩ Normalize namespaces in temp manifests
        run: |
          set -e
          echo "üßπ Normalizing metadata.namespace to '${KUBE_NAMESPACE}'..."
          find /tmp/k8s-updated -type f -name "*.yaml" -print0 \
            | xargs -0 sed -i -E 's/\b(june-services)(-services)+\b/\1/g'
          find /tmp/k8s-updated -type f -name "*.yaml" -print0 \
            | xargs -0 sed -i -E "s/^( *namespace:\s*)june\b/\\1${KUBE_NAMESPACE}/g"
          find /tmp/k8s-updated -type f -name "*.yaml" -print0 \
            | xargs -0 sed -i -E "s/^( *namespace:\s*)[a-zA-Z0-9_-]+$/\\1${KUBE_NAMESPACE}/"
          echo "üîé Namespaces after normalization:"
          grep -RIn --include='*.yaml' '^[[:space:]]*namespace:' /tmp/k8s-updated || true

      - name: üèóÔ∏è Apply base configuration
        run: |
          echo "üèóÔ∏è Applying base Kubernetes resources..."
          [ -f "/tmp/k8s-updated/configmap.yaml" ] && kubectl apply -n "$KUBE_NAMESPACE" -f /tmp/k8s-updated/configmap.yaml || true
          [ -f "/tmp/k8s-updated/secrets.yaml" ]   && kubectl apply -n "$KUBE_NAMESPACE" -f /tmp/k8s-updated/secrets.yaml || true
          echo "‚ÑπÔ∏è Storage is owned by the install script; skipping here."

      - name: üóÑÔ∏è Deploy PostgreSQL first
        run: |
          echo "üóÑÔ∏è Deploying PostgreSQL for june-idp..."
          if kubectl get statefulset postgresql -n "$KUBE_NAMESPACE" &>/dev/null; then
            echo "‚úÖ PostgreSQL StatefulSet already exists"
          else
            kubectl apply -f k8s/postgresql-deployment.yaml
          fi
          
          echo "‚è≥ Waiting for PostgreSQL pod to be created..."
          for i in {1..30}; do
            POD_NAME=$(kubectl get pods -n "$KUBE_NAMESPACE" -l app=postgresql -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ -n "$POD_NAME" ]; then
              echo "‚úÖ PostgreSQL pod created: $POD_NAME"
              break
            fi
            echo "  Waiting for pod... ($i/30)"
            sleep 2
          done
          
          echo "‚è≥ Waiting for PostgreSQL to be ready..."
          kubectl wait --for=condition=ready pod -l app=postgresql -n "$KUBE_NAMESPACE" --timeout=180s || {
            echo "‚ö†Ô∏è PostgreSQL not ready yet, checking status..."
            kubectl get pods -n "$KUBE_NAMESPACE" -l app=postgresql
            kubectl describe pod -n "$KUBE_NAMESPACE" -l app=postgresql | tail -30
          }
          
          echo "‚úÖ PostgreSQL is ready"

      - name: üöÄ Deploy services
        run: |
          echo "üöÄ Deploying services..."
          SERVICES_INPUT="${{ github.event.inputs.services }}"
          ALL_SERVICES=("june-stt" "june-tts" "june-orchestrator" "june-idp" "june-web" "june-dark")

          if [ -z "$SERVICES_INPUT" ]; then
            SERVICES_TO_DEPLOY=("${ALL_SERVICES[@]}")
          else
            IFS=',' read -ra SERVICES_TO_DEPLOY <<< "$SERVICES_INPUT"
          fi

          if [ -f "/tmp/k8s-updated/complete-manifests.yaml" ]; then
            kubectl apply -n "$KUBE_NAMESPACE" -f /tmp/k8s-updated/complete-manifests.yaml
          else
            for service in "${SERVICES_TO_DEPLOY[@]}"; do
              service="$(echo "$service" | xargs)"
              if [ -f "/tmp/k8s-updated/${service}-deployment.yaml" ]; then
                kubectl apply -n "$KUBE_NAMESPACE" -f "/tmp/k8s-updated/${service}-deployment.yaml"
              else
                echo "‚ö†Ô∏è /tmp/k8s-updated/${service}-deployment.yaml not found"
              fi
            done
          fi

      - name: üñáÔ∏è Enforce images on live deployments
        run: |
          set -e
          for DEP in $(kubectl -n "$KUBE_NAMESPACE" get deploy -o jsonpath='{.items[*].metadata.name}'); do
            case "$DEP" in
              june-stt)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP stt=${REGISTRY}/june-stt:${IMAGE_TAG} --record ;;
              june-tts)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP tts=${REGISTRY}/june-tts:${IMAGE_TAG} --record ;;
              june-orchestrator) kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP orchestrator=${REGISTRY}/june-orchestrator:${IMAGE_TAG} --record ;;
              june-idp)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP keycloak=${REGISTRY}/june-idp:${IMAGE_TAG} --record ;;
              june-web)          kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP web=${REGISTRY}/june-web:${IMAGE_TAG} --record || true ;;
              june-dark)         kubectl -n "$KUBE_NAMESPACE" set image deploy/$DEP dark=${REGISTRY}/june-dark:${IMAGE_TAG} --record || true ;;
            esac
          done

      - name: üåê Apply ingress with TLS
        run: |
          echo "üåê Applying ingress with TLS configuration..."
          
          if [ -f "/tmp/k8s-updated/ingress.yaml" ]; then
            if ! grep -q "cert-manager.io/cluster-issuer" /tmp/k8s-updated/ingress.yaml; then
              echo "‚ö†Ô∏è Adding cert-manager annotation to ingress..."
              kubectl annotate ingress june-ingress \
                -n "$KUBE_NAMESPACE" \
                cert-manager.io/cluster-issuer=letsencrypt-prod \
                --overwrite || true
            fi
            
            kubectl apply -f /tmp/k8s-updated/ingress.yaml
          elif [ -f "k8s-ingress-complete.yaml" ]; then
            kubectl apply -f k8s-ingress-complete.yaml
          else
            echo "‚ö†Ô∏è No ingress configuration found"
          fi
          
          echo "üîç Verifying ingress TLS configuration..."
          ISSUER=$(kubectl get ingress june-ingress -n "$KUBE_NAMESPACE" -o jsonpath='{.metadata.annotations.cert-manager\.io/cluster-issuer}' 2>/dev/null || echo "none")
          
          if [ "$ISSUER" = "none" ]; then
            echo "‚ö†Ô∏è Ingress missing cert-manager annotation, adding it..."
            kubectl annotate ingress june-ingress \
              -n "$KUBE_NAMESPACE" \
              cert-manager.io/cluster-issuer=letsencrypt-prod \
              --overwrite
          elif [ "$ISSUER" = "letsencrypt-staging" ]; then
            echo "‚ö†Ô∏è Ingress using staging certificate, switching to production..."
            kubectl annotate ingress june-ingress \
              -n "$KUBE_NAMESPACE" \
              cert-manager.io/cluster-issuer=letsencrypt-prod \
              --overwrite
          else
            echo "‚úÖ Ingress configured with issuer: $ISSUER"
          fi
          
          kubectl -n "$KUBE_NAMESPACE" get ingress -o wide || true
          
          echo "‚è≥ Waiting for TLS certificate to be ready..."
          sleep 10
          
          for i in {1..30}; do
            CERT_READY=$(kubectl get certificate allsafe-tls -n "$KUBE_NAMESPACE" -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
            
            if [ "$CERT_READY" = "True" ]; then
              echo "‚úÖ TLS certificate is ready!"
              break
            fi
            
            echo "‚è≥ Certificate status: $CERT_READY (waiting...)"
            sleep 10
          done
          
          echo "üìä Certificate status:"
          kubectl get certificate -n "$KUBE_NAMESPACE" || echo "No certificates found yet"

      - name: ‚è≥ Wait for deployments
        run: |
          echo "‚è≥ Waiting for deployments to be ready..."
          DEPLOYMENTS=$(kubectl get deployments -n "$KUBE_NAMESPACE" -o jsonpath='{.items[*].metadata.name}')
          for deployment in $DEPLOYMENTS; do
            kubectl rollout status deployment/"$deployment" -n "$KUBE_NAMESPACE" --timeout=300s || true
          done

      - name: üîç Health check
        run: |
          echo "üìä Pods:";    kubectl -n "$KUBE_NAMESPACE" get pods -o wide || true
          echo "üåê Svc:";     kubectl -n "$KUBE_NAMESPACE" get svc -o wide || true
          echo "üö™ Ingress:"; kubectl -n "$KUBE_NAMESPACE" get ingress -o wide || true
          echo "üîê Certs:";   kubectl -n "$KUBE_NAMESPACE" get certificate || true

      - name: üìä Final status
        if: always()
        run: |
          kubectl get all -n "$KUBE_NAMESPACE" -o wide || true
          
          echo ""
          echo "üîê TLS Certificate Status:"
          kubectl get certificate -n "$KUBE_NAMESPACE" || echo "No certificates found"
          
          echo ""
          echo "üéÆ GPU Status:"
          kubectl describe nodes | grep -A 5 "Capacity:" | grep nvidia.com/gpu || echo "No GPU resources found"
          
          echo ""
          echo "üåê External Access Information:"
          EXTERNAL_IP=$(curl -s http://checkip.amazonaws.com/ 2>/dev/null || echo "Unable to detect")
          echo "   External IP: $EXTERNAL_IP"
          echo ""
          echo "üß™ Test your services with HTTPS:"
          echo "   curl https://api.allsafe.world/healthz"
          echo "   curl https://idp.allsafe.world/"
          echo ""
          echo "üîç Check certificate in browser:"
          echo "   https://api.allsafe.world"
          echo "   https://idp.allsafe.world"